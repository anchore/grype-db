package main

import (
	"slices"
	"strings"

	"github.com/anchore/grype-db/cmd/build-cve-set-lookup/termset"
)

type match struct {
	product        *product
	percent        float64
	directCpeMatch bool
	terms          termset.Set
}

func lookupProduct(lookups lookups, searchTerms termset.Set) []match {
	// get all products that match _any_ term along with their match percentage
	got := map[*product]struct{}{}
	var matches []match
	for term := range searchTerms {
		for _, p := range lookups.termsToProducts[term] {
			if p == nil {
				continue
			}
			if _, ok := got[p]; ok {
				continue
			}
			matchingTerms := termset.New()
			for t := range p.weights {
				if searchTerms.Has(t) {
					matchingTerms.Add(t)
				}
			}
			directCpeMatch := false
			for t := range p.cpeTerms {
				if searchTerms.Has(t) {
					directCpeMatch = true
					matchingTerms.Add(t)
				}
			}
			if len(matchingTerms) > 0 {
				got[p] = struct{}{}
				matches = append(matches, match{
					p,
					getMatchPercent(p, searchTerms),
					directCpeMatch,
					matchingTerms,
				})
			}
		}
	}

	// order by match percent
	slices.SortFunc(matches, func(a, b match) int {
		// favor direct cpe value matches
		// if a.directCpeMatch && !b.directCpeMatch {
		//	return 1
		//}
		//if !a.directCpeMatch && b.directCpeMatch {
		//	return -1
		//}

		if a.percent == b.percent {
			return strings.Compare(a.product.cpe, b.product.cpe)
		}
		if a.percent < b.percent {
			return 1
		}
		return -1
	})

	// favor matches that have at least something matching in the vendorProduct string
	if len(matches) > 5 {
		return matches[0:5]
	}

	return matches
}

func getMatchPercent(p *product, searchTerms termset.Set) float64 {
	matchFactor := 0.
	for term := range p.weights {
		// don't count single-digit number matches... ehhh
		//if len(term) == 1 && unicode.IsDigit(rune(term[0])) {
		//	continue
		//}
		if searchTerms.Has(term) {
			matchFactor += p.weights[term]
		}
	}
	return matchFactor
}
