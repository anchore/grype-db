package main

import (
	"slices"
	"strings"
	"unicode"

	"github.com/anchore/grype-db/cmd/build-cve-set-lookup/termset"
)

type match struct {
	product *product
	percent float64
}

func lookupProduct(termToProducts map[string][]*product, searchTerms termset.Set) []match {
	// get all products that match _any_ term along with their match percentage
	got := map[*product]struct{}{}
	var matches []match
	for term := range searchTerms {
		for _, p := range termToProducts[term] {
			if p == nil {
				continue
			}
			if _, ok := got[p]; ok {
				continue
			}
			got[p] = struct{}{}
			matches = append(matches, match{
				p,
				getMatchPercent(p, searchTerms),
			})
		}
	}

	// order by match percent
	slices.SortFunc(matches, func(a, b match) int {
		if a.percent == b.percent {
			return strings.Compare(a.product.cpeVendorProduct, b.product.cpeVendorProduct)
		}
		if a.percent < b.percent {
			return 1
		}
		return -1
	})

	// favor matches that have at least something matching in the vendorProduct string
	var directMatches []match
	for _, m := range matches {
		for term := range getTextTerms(m.product.cpeVendorProduct) {
			if searchTerms.Has(term) {
				directMatches = append(directMatches, m)
				break
			}
		}
	}

	if len(directMatches) > 0 {
		matches = append(directMatches, matches...)
	}

	if len(matches) > 5 {
		return matches[0:5]
	}

	return matches
}

func getMatchPercent(p *product, searchTerms termset.Set) float64 {
	matchCount := 0.
	for term := range p.terms {
		// don't count single-digit number matches... ehhh
		if len(term) == 1 && unicode.IsDigit(rune(term[0])) {
			continue
		}
		if searchTerms.Has(term) {
			matchCount++
		}
	}
	return matchCount / float64(len(p.terms))
}
