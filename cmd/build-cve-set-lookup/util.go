package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	"unicode"

	"github.com/facebookincubator/nvdtools/wfn"
)

func log(msgs ...any) {
	if len(msgs) < 1 {
		return
	}
	msg, ok := msgs[0].(string)
	if ok && strings.Contains(msg, "%") {
		// use as format string
		msg = fmt.Sprintf(msg, msgs[1:]...)
	} else {
		msg = ""
		for _, m := range msgs {
			if len(msg) > 0 {
				msg += " "
			}
			msg += fmt.Sprintf("%v", m)
		}
	}
	_, _ = fmt.Fprintln(os.Stderr, msg)
}

// panget gets the value or panics on error, useful for (value, error) returns
func logget[T any](value T, err error) T {
	logif(err)
	return value
}

// panget gets the value or panics on error, useful for (value, error) returns
func panget[T any](value T, err error) T {
	panif(err)
	return value
}

// panif panics on error
func panif(err error) {
	if err != nil {
		panic(err)
	}
}

// logif logs if a non-nil error
func logif(err error) {
	if err != nil {
		log(err)
	}
}

// whitespace includes nbsp (#160) considered to be a space character
var whitespace = regexp.MustCompile(`[\s\xa0]+`)

// var disallowedChars = regexp.MustCompile(`[^ ._\-();/<>\pL\pN]`)
var disallowedChars = regexp.MustCompile(`[^\pL\pN]+`)

// remove modifies the slice by removing the first matching element from it and returns the slice, for convenience
func remove[T comparable](values []T, valueToRemove T) []T {
	if values == nil {
		return nil
	}
	for i, value := range values {
		if value == valueToRemove {
			return append(values[:i], values[i+1:]...)
		}
	}
	// wasn't found
	return values
}

// isHashLike returns true for things that look like they could be hashes, e.g. a8b7s32cf932a or very long numbers
func isHashLike(term string) bool {
	if len(term) < 6 {
		return false
	}

	digitCount := 0
	numberFollowsLetter := 0
	letterFollowsNumber := 0
	last := rune(term[0])
	for _, chr := range term[1:] {
		if unicode.IsDigit(last) && unicode.IsLetter(chr) {
			letterFollowsNumber++
		}
		if unicode.IsLetter(last) && unicode.IsDigit(chr) {
			numberFollowsLetter++
		}
		if unicode.IsDigit(chr) {
			digitCount++
		}
		last = chr
	}

	return digitCount > 6 || (numberFollowsLetter > 1 && letterFollowsNumber > 1)
}

func mergeAll[T any](everything [][]T) []T {
	var out []T
	for _, result := range everything {
		out = append(out, result...)
	}
	return out
}

func toVendorProduct(w *wfn.Attributes) string {
	// vendorProduct := fmt.Sprintf("%s:%s:%s:%s", w.Part, w.Vendor, w.Product, w.TargetSW)
	vendorProduct := fmt.Sprintf("%s:%s:%s", w.Vendor, w.Product, w.TargetSW)
	vendorProduct = strings.ReplaceAll(vendorProduct, "\\", "")
	return vendorProduct
}
