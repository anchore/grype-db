package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"regexp"
	"runtime"
	"slices"
	"strconv"
	"strings"

	"github.com/bmatcuk/doublestar/v4"
	"github.com/dustin/go-humanize"
	"github.com/mitchellh/go-homedir"
	_ "modernc.org/sqlite"

	"github.com/anchore/go-sync"
	"github.com/anchore/grype-db/cmd/build-cve-set-lookup/termset"
)

func main() {
	nvdDbFile := "~/projects/grype-db/data/vunnel/nvd/results/results.db"
	cveListDir := "~/Downloads/cvelistV5-main/cves-2024-03-05"
	csvFile := "~/projects/grype-db/cmd/build-cve-set-lookup/testdata/.tmp/product_version_all.csv"

	// expand easier to use paths
	nvdDbFile = panget(homedir.Expand(nvdDbFile))
	cveListDir = panget(homedir.Expand(cveListDir))
	csvFile = panget(homedir.Expand(csvFile))

	defer func() {
		memStats := runtime.MemStats{}
		runtime.ReadMemStats(&memStats)
		log("used memory:", humanize.Bytes(memStats.Alloc))
	}()

	timer := newStopwatch()

	var cvesToSearch []string
	if len(os.Args) > 1 {
		action := os.Args[1]
		switch action {
		case "show-descriptions":
			showDescriptions(csvFile, cveListDir, os.Args[2])
			return
		case "lookup-csv":
			cvesToSearch = cvesFromCSV("~/Downloads/candidates.csv")
			log("read candidates csv took:", timer.lap())
		case "lookup":
			cvesToSearch = os.Args[2:]
		}
	}

	lookups := process(sync.NewExecutor(-1), nvdDbFile, cveListDir)
	log("process took:", timer.lap())

	csvLines := [][]string{{"product", "cves", "text"}}
	for _, p := range lookups.allProducts {
		txt := sortedTermPercent(p.weights)
		cves := strings.Join(p.cves.List(), " ")
		csvLines = append(csvLines, []string{p.cpe, cves, txt})
	}
	writeCSVFile(csvFile, csvLines)
	log("write CSV results took:", timer.lap())

	// lookup:
	for _, cve := range cvesToSearch {
		searchText := searchTextFromCVE(cveListDir, cve)
		searchTerms := getTextTerms(searchText)
		// searchTerms.Remove(removeWords.List()...)

		matches := lookupProduct(lookups, searchTerms)

		fmt.Printf("SEARCH %s '%s':", cve, searchText)
		fmt.Println()
		for _, m := range matches {
			fmt.Printf("  - %s (%.2f)", m.product.cpe, m.percent)
			fmt.Println()
		}

		fmt.Println()
		log("lookup", cve, "took:", timer.lap())
	}
}

func sortedTermPercent(terms termset.Set) string {
	type termPct struct {
		term string
		pct  float64
	}

	var sorted []termPct
	for term, pct := range terms {
		sorted = append(sorted, termPct{
			term,
			pct,
		})
	}
	slices.SortFunc(sorted, func(a, b termPct) int {
		if a.pct == b.pct {
			return strings.Compare(a.term, b.term)
		}
		// sort highest percentage first
		if a.pct < b.pct {
			return 1
		}
		return -1
	})
	buf := bytes.Buffer{}
	for _, term := range sorted {
		_, _ = fmt.Fprintf(&buf, "%s %v ", term.term, term.pct)
	}
	return buf.String()
}

type product struct {
	cpe        string
	cpeTerms   termset.Set
	cveMaxYear int
	cves       termset.Set
	terms      termset.Set
	weights    termset.Set
}

func cveFileName(cveListDir, cve string) string {
	parts := strings.Split(cve, "-")
	year := parts[1]
	num := parts[2]
	subdir := fmt.Sprintf("%sxxx", num[0:len(num)-3])
	return path.Join(cveListDir, year, subdir, fmt.Sprintf("CVE-%s-%s.json", year, num))
}

func searchTextFromCVE(cveListDir string, cve string) string {
	file := cveFileName(cveListDir, cve)
	records := readCVEFiles(sync.NewExecutor(0), cveListDir, strings.TrimPrefix(file, cveListDir))
	var text []string
	for _, r := range records {
		text = append(text, r.text...)
	}
	return strings.Join(text, " ")
}

func _searchTextFromCVE(cveListDir string, cve string) string {
	cveFile := logget(os.ReadFile(cveFileName(cveListDir, cve)))
	if cveFile == nil {
		log("file not found for:", cveListDir, cve)
		return ""
	}

	var cveRec cveRecord
	logif(json.Unmarshal(cveFile, &cveRec))

	var text []string
	for _, reference := range cveRec.Containers.Cna.References {
		url := reference.Url
		if url != "" {
			text = append(text, url)
		}
	}

	for _, description := range cveRec.Containers.Cna.Descriptions {
		if description.Lang == "en" {
			text = append(text, description.Value)
		}
	}

	return cveRec.CveMetadata.ID + " " + strings.Join(text, " ")
}

func showDescriptions(csvFile, cveListDir string, vendorProduct string) {
	rdr := csv.NewReader(panget(os.Open(csvFile)))
	// skip header row
	_, _ = rdr.Read() // skip headers
	for row, err := rdr.Read(); err == nil; row, err = rdr.Read() {
		if strings.Contains(row[0], "washington") {
			fmt.Print()
		}
		if vendorProduct == row[0] {
			for _, cve := range strings.Split(row[1], " ") {
				matched := panget(doublestar.FilepathGlob(path.Join(cveListDir, "**", strings.ToUpper(cve)+".json")))
				if len(matched) != 1 {
					panic(fmt.Sprintf("incorrect CVE file matches: %v", matched))
				}
				cveFile := matched[0]

				var cveRec cveRecord
				logif(json.Unmarshal(logget(os.ReadFile(cveFile)), &cveRec))

				if cveRec.CveMetadata.ID == "" {
					log("no cveId in:", cveFile)
					continue
				}

				var text []string
				for _, reference := range cveRec.Containers.Cna.References {
					url := reference.Url
					if url != "" {
						text = append(text, url)
					}
				}

				for _, description := range cveRec.Containers.Cna.Descriptions {
					if description.Lang == "en" {
						text = append(text, description.Value)
					}
				}

				fmt.Printf("%s:", cveFile)
				fmt.Println()
				for _, part := range text {
					fmt.Printf("    %s", part)
					fmt.Println()
				}
			}
			return
		}
	}
}

func parseCpeTerms(cpeParts string) termset.Set {
	terms := termset.New()
	for _, part := range strings.Split(cpeParts, ":") {
		if len(part) < 2 {
			continue
		}
		terms.AddAll(getTextTerms(part))
	}
	return terms
}

func isNumber(term string) bool {
	_, err := strconv.ParseFloat(term, 64)
	return err == nil
}

func parseTerms(r rec) termset.Set {
	out := termset.Set{}
	for _, txt := range r.text {
		out.AddAll(getTextTerms(txt))
	}
	return out
}

var urlPat = regexp.MustCompile(`https?://[^\s]+`)
var urlSplitter = regexp.MustCompile(`[./]`)

var keepHosts = termset.New(
	"github.com",
)

func isKnownVersionType(versionType string) bool {
	versionType = strings.ToLower(versionType)
	switch versionType {
	case "general", "release", "patch", "python", "rpm", "affected", "general availability", "semver", "maven", "original_commit_for_fix":
		return true
	default:
		return false
	}
	// return alpha.MatchString(versionType)
}

type rec struct {
	cve  string
	cpe  string
	text []string
}
