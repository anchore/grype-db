package main

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
	"regexp"
	"runtime"
	"slices"
	"strconv"
	"strings"
	"sync"

	"github.com/bmatcuk/doublestar/v4"
	"github.com/dustin/go-humanize"
	"github.com/facebookincubator/nvdtools/wfn"
	"github.com/mitchellh/go-homedir"
	"golang.org/x/exp/maps"
	_ "modernc.org/sqlite"

	"github.com/anchore/grype-db/cmd/build-cve-set-lookup/termset"
	"github.com/anchore/grype-db/pkg/provider/unmarshal/nvd/cvss31"
)

func main() {
	nvdDbFile := "~/projects/grype-db/data/vunnel/nvd/results/results.db"
	//nvdCpeListFile := "~/Downloads/cvelistV5-main/official-cpe-dictionary_v2.3.xml"
	cveListDir := "~/Downloads/cvelistV5-main/cves-2024-03-05"
	cveJsonFileGlob := "*/**/*.json"
	//cveJsonFileGlob = "2024/*/*.json"
	//cveJsonFileGlob = "*/**/CVE-{1999-0947,2005-1086,2005-1087}.json"
	csvFile := "~/projects/vunnel/src/classifier/product_version_all.csv"
	//allDbFiles := "~/projects/grype-db/data/vunnel/*/results/results.db"

	// expand easier to use paths
	cveListDir = panget(homedir.Expand(cveListDir))
	csvFile = panget(homedir.Expand(csvFile))

	defer func() {
		memStats := runtime.MemStats{}
		runtime.ReadMemStats(&memStats)
		log("used memory:", humanize.Bytes(memStats.Alloc))
	}()

	if len(os.Args) > 1 {
		action := os.Args[1]
		switch action {
		case "show-descriptions":
			showDescriptions(csvFile, cveListDir, os.Args[2])
			return
		}
	}

	lookups := []string{
		//"CVE-2023-46951",
		//"CVE-2023-49250",
		//"CVE-2023-51931",
		//"CVE-2024-1297",
		//"CVE-2024-1722",
		//"CVE-2024-1892",
		//"CVE-2024-21502",
		//"CVE-2024-22369",
		//"CVE-2024-24758",
		//"CVE-2024-25126",
		//"CVE-2024-25625",
		//"CVE-2024-26308",
		//"CVE-2024-27133",
	}

	lookups = cvesFromCSV("~/Downloads/candidates.csv")

	nvdDbFile = panget(homedir.Expand(nvdDbFile))
	nvdDb := panget(sql.Open("sqlite", nvdDbFile))
	defer func() { logif(nvdDb.Close()) }()

	timer := newTimer()
	timer.snap("started")

	paths := panget(doublestar.FilepathGlob(path.Join(cveListDir, cveJsonFileGlob)))

	var knownRecords []rec
	wg := sync.WaitGroup{}
	wg2 := sync.WaitGroup{}
	records := make(chan rec)
	go func() {
		wg2.Add(1)
		defer wg2.Done()
		for r := range records {
			knownRecords = append(knownRecords, r)
		}
	}()
	for _, p := range paths {
		wg.Add(1)
		go func(p string) {
			defer wg.Done()
			for _, item := range readCveFile(p) {
				records <- item
			}
		}(p)
	}
	wg.Wait()
	close(records)
	wg2.Wait()
	timer.snap("readCveFiles")
	log("known record count: %v", len(knownRecords))

	cpeToVendorProduct := readCpeToVendorProduct(nvdDb)
	timer.snap("readCpeToVendorProduct")

	knownRecords = filterKnownRecordsToSingleCpe(cpeToVendorProduct, knownRecords)
	timer.snap("filterKnownRecordsToSingleCpe")
	log("single-cpe record count: %v", len(knownRecords))

	//termToVendorProduct, byVendorProduct, removeWords := buildLookups(knownRecords)
	termToProducts, byVendorProduct, _ := buildLookups(knownRecords)
	timer.snap("buildLookups")

	csvLines := [][]string{{"product", "cves", "text"}}
	for _, p := range byVendorProduct {
		txt := strings.Join(p.terms.List(), " ")
		cves := strings.Join(p.cves.List(), " ")
		csvLines = append(csvLines, []string{p.cpeVendorProduct, cves, txt})
	}
	writeCSVFile(csvFile, csvLines)
	timer.snap("write CSV results")

	// lookup:
	for _, cve := range lookups {
		searchText := searchTextFromCVE(cveListDir, cve)
		searchTerms := getTextTerms(searchText)
		//searchTerms.Remove(removeWords.List()...)

		matches := lookupProduct(termToProducts, searchTerms)

		fmt.Printf("SEARCH '%s':", searchText)
		fmt.Println()
		for _, m := range matches {
			fmt.Printf("  - %s (%.2f%%)", m.product.cpeVendorProduct, m.percent*100)
			fmt.Println()
		}

		fmt.Println()
		timer.snap("lookup " + cve)
	}
}

func filterKnownRecordsToSingleCpe(cveToVendorProduct map[string][]string, records []rec) []rec {
	var out []rec
	for _, r := range records {
		r, ok := filterKnownRecordToSingleCpe(cveToVendorProduct, r)
		if ok {
			out = append(out, r)
		}
	}
	return out
}

func filterKnownRecordToSingleCpe(cveToVendorProduct map[string][]string, r rec) (rec, bool) {
	if r.cpeVendorProduct != "" {
		// already set, use it
		return r, true
	}

	if len(cveToVendorProduct[r.cve]) != 1 {
		// none or too many values to know the right one
		return r, false
	}

	// exactly 1 record, use it
	r.cpeVendorProduct = cveToVendorProduct[r.cve][0]
	return r, true
}

type cveRecord struct {
	CveMetadata struct {
		ID    string `json:"cveId"`
		State string `json:"state"`
	} `json:"cveMetadata"`
	Containers struct {
		Cna struct {
			Affected []struct {
				Vendor      string `json:"vendor"`
				Product     string `json:"product"`
				PackageName string `json:"packageName"`
				Versions    []struct {
					Version     string `json:"version"`
					VersionType string `json:"versionType"`
					LessThan    string `json:"lessThan"`
				} `json:"versions"`
				Cpes []string `json:"cpes"`
			} `json:"affected"`
			References []struct {
				Url string `json:"url"`
			} `json:"references"`
			Descriptions []struct {
				Lang  string `json:"lang"`
				Value string `json:"value"`
			} `json:"descriptions"`
			Metrics []struct {
				cvss31.Cvss31 `json:"cvssV3_1"`
			} `json:"metrics"`
		} `json:"cna"`
	} `json:"containers"`
}

func cveFileName(cveListDir, cve string) string {
	parts := strings.Split(cve, "-")
	year := parts[1]
	num := parts[2]
	subdir := fmt.Sprintf("%sxxx", num[0:len(num)-3])
	return path.Join(cveListDir, year, subdir, fmt.Sprintf("CVE-%s-%s.json", year, num))
}

func cvesFromCSV(csvFile string) []string {
	var cves []string
	rdr := csv.NewReader(panget(os.Open(panget(homedir.Expand(csvFile)))))
	_, _ = rdr.Read() // skip headers
	for row, err := rdr.Read(); err == nil; row, err = rdr.Read() {
		cves = append(cves, row[0])
	}
	return cves
}

func searchTextFromCVE(cveListDir string, cve string) string {
	cveFile := logget(os.ReadFile(cveFileName(cveListDir, cve)))
	if cveFile == nil {
		log("file not found for:", cveListDir, cve)
		return ""
	}

	var cveRec cveRecord
	logif(json.Unmarshal(cveFile, &cveRec))

	var text []string
	for _, reference := range cveRec.Containers.Cna.References {
		url := reference.Url
		if url != "" {
			text = append(text, url)
		}
	}

	for _, description := range cveRec.Containers.Cna.Descriptions {
		if description.Lang == "en" {
			text = append(text, description.Value)
		}
	}

	return cveRec.CveMetadata.ID + " " + strings.Join(text, " ")
}

func showDescriptions(csvFile, cveListDir string, vendorProduct string) {
	rdr := csv.NewReader(panget(os.Open(csvFile)))
	// skip header row
	_, _ = rdr.Read() // skip headers
	for row, err := rdr.Read(); err == nil; row, err = rdr.Read() {
		if strings.Contains(row[0], "washington") {
			fmt.Print()
		}
		if vendorProduct == row[0] {
			for _, cve := range strings.Split(row[1], " ") {
				matched := panget(doublestar.FilepathGlob(path.Join(cveListDir, "**", strings.ToUpper(cve)+".json")))
				if len(matched) != 1 {
					panic(fmt.Sprintf("incorrect CVE file matches: %v", matched))
				}
				cveFile := matched[0]

				var cveRec cveRecord
				logif(json.Unmarshal(logget(os.ReadFile(cveFile)), &cveRec))

				if cveRec.CveMetadata.ID == "" {
					log("no cveId in:", cveFile)
					continue
				}

				var text []string
				for _, reference := range cveRec.Containers.Cna.References {
					url := reference.Url
					if url != "" {
						text = append(text, url)
					}
				}

				for _, description := range cveRec.Containers.Cna.Descriptions {
					if description.Lang == "en" {
						text = append(text, description.Value)
					}
				}

				fmt.Printf("%s:", cveFile)
				fmt.Println()
				for _, part := range text {
					fmt.Printf("    %s", part)
					fmt.Println()
				}
			}
			return
		}
	}
}

func buildLookups(knownRecords []rec) (termToProducts map[string][]*product, byVendorProduct map[string]*product, removeWords termset.Set) {
	termToProducts = map[string][]*product{}
	byVendorProduct = map[string]*product{}

	for _, knownRecord := range knownRecords {
		terms := getTerms(knownRecord)

		existing := byVendorProduct[knownRecord.cpeVendorProduct]
		if existing == nil {
			prod := &product{
				cves:             termset.New(knownRecord.cve),
				cpeVendorProduct: knownRecord.cpeVendorProduct,
				terms:            terms,
				secondary:        termset.New(),
			}
			byVendorProduct[knownRecord.cpeVendorProduct] = prod
			for term := range prod.terms {
				termToProducts[term] = append(termToProducts[term], prod)
			}
			continue
		}

		// add the cve
		existing.cves.Add(knownRecord.cve)

		// TODO FIXME weight the terms

		// if we find existing records, remove terms that are not in both sets
		for existingTerm := range existing.terms {
			if !terms.Has(existingTerm) {
				existing.terms.Remove(existingTerm)
				existing.secondary.Add(existingTerm)
				termToProducts[existingTerm] = remove(termToProducts[existingTerm], existing)
			}
		}
	}

	return removeHighFrequencyTerms(termToProducts, byVendorProduct, 1000)
}

var keepWords = termset.New(
	"php",
	"android",
	"java",
	"ibm",
	"github",
	"microsoft",
)

func removeHighFrequencyTerms(termToProducts map[string][]*product, byVendorProduct map[string]*product, topNumWords int) (map[string][]*product, map[string]*product, termset.Set) {
	termCounts := termset.Set{}
	for _, p := range byVendorProduct {
		termCounts.AddAll(p.terms)
	}

	// get terms sorted by frequency
	terms := maps.Keys(termToProducts)
	slices.SortFunc(terms, func(a, b string) int {
		numA := termCounts[a]
		numB := termCounts[b]
		if numA == numB {
			return strings.Compare(a, b)
		}
		if numA > numB {
			return -1
		}
		return 1
	})

	removeWords := termset.Set{}
	for _, term := range terms {
		if keepWords.Has(term) || isNumber(term) {
			continue
		}

		products := termToProducts[term]
		var newProducts []*product
		for _, p := range products {
			// if the vendorProduct text has the term, keep it regardless of the frequency seen
			keep := getTextTerms(p.cpeVendorProduct)
			if keep.Has(term) {
				newProducts = append(newProducts, p)
				continue
			}
			p.terms.Remove(term)
		}

		// if the term was not something in a vendorProduct string, delete the index entry
		if len(newProducts) > 0 {
			termToProducts[term] = newProducts
		} else {
			delete(termToProducts, term)
		}

		removeWords.Add(term)
		topNumWords--
		if topNumWords <= 0 {
			break
		}
	}

	return termToProducts, byVendorProduct, removeWords
}

func isNumber(term string) bool {
	_, err := strconv.ParseFloat(term, 64)
	return err == nil
}

func readCveFile(cveFile string) (records []rec) {
	var cveRec cveRecord
	logif(json.Unmarshal(logget(os.ReadFile(cveFile)), &cveRec))

	if cveRec.CveMetadata.State == "REJECTED" {
		// skip rejected CVEs, as they may be wrong or just have no data
		return nil
	}

	if cveRec.CveMetadata.ID == "" {
		log("no cveId in:", cveFile)
		return nil
	}

	var text []string
	for _, reference := range cveRec.Containers.Cna.References {
		url := reference.Url
		if url != "" {
			text = append(text, url)
		}
	}

	for _, description := range cveRec.Containers.Cna.Descriptions {
		if description.Lang == "en" {
			text = append(text, description.Value)
		}
	}

	if len(text) == 0 {
		log("no usable text in: ", cveFile)
		return nil
	}

	cveId := normalizeCve(cveRec.CveMetadata.ID)

nextAffected:
	for _, a := range cveRec.Containers.Cna.Affected {
		item := rec{
			cve:  cveId,
			text: append([]string{a.Vendor, a.Product, a.PackageName}, text...),
		}

		// if there are CPEs explicitly defined, use those
		for _, c := range a.Cpes {
			cpe, _ := wfn.Parse(fmt.Sprintf("%v", c))
			if cpe == nil {
				continue
			}
			cpeVendorProduct := toVendorProduct(cpe)
			if item.cpeVendorProduct != "" && item.cpeVendorProduct != cpeVendorProduct {
				// there really shouldn't be multiple _different_ cpes, we won't know the right one to use
				continue nextAffected
			}
			item.cpeVendorProduct = cpeVendorProduct
		}

		records = append(records, item)
	}

	return records
}

func toVendorProduct(w *wfn.Attributes) string {
	//vendorProduct := fmt.Sprintf("%s:%s:%s:%s", w.Part, w.Vendor, w.Product, w.TargetSW)
	vendorProduct := fmt.Sprintf("%s:%s:%s", w.Vendor, w.Product, w.TargetSW)
	vendorProduct = strings.ReplaceAll(vendorProduct, "\\", "")
	return vendorProduct
}

func getTerms(r rec) termset.Set {
	out := termset.Set{}
	for _, txt := range r.text {
		out.AddAll(getTextTerms(txt))
	}
	return out
}

var urlPat = regexp.MustCompile(`https?://[^\s]+`)
var urlSplitter = regexp.MustCompile(`[./]`)

var keepHosts = termset.New(
	"github.com",
)

type product struct {
	cpeVendorProduct string
	cves             termset.Set
	terms            termset.Set
	secondary        termset.Set
}

func writeCSVFile(file string, records [][]string) {
	f := panget(os.Create(file))
	defer func() {
		logif(f.Close())
	}()
	writeCSV(f, records)
}

func writeCSV(writer io.Writer, records [][]string) {
	for _, r := range records {
		writeRow(writer, r...)
	}
}

func writeRow(writer io.Writer, values ...string) {
	for i, v := range values {
		if i > 0 {
			_ = logget(fmt.Fprint(writer, `,`))
		}
		_ = logget(fmt.Fprintf(writer, `"%s"`, v))
	}
	_ = logget(fmt.Fprintln(writer))
}

var stopwords = fetchStopwords()

func fetchStopwords() map[string]struct{} {
	//url := "https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt"
	url := "https://gist.githubusercontent.com/rg089/35e00abf8941d72d419224cfd5b5925d/raw/12d899b70156fd0041fa9778d657330b024b959c/stopwords.txt"

	rsp := panget(http.Get(url))
	defer func() {
		logif(rsp.Body.Close())
	}()

	list := string(panget(io.ReadAll(rsp.Body)))

	words := map[string]struct{}{}
	for _, word := range strings.Split(list, "\n") {
		word = strings.TrimSpace(word)
		word = strings.ToLower(word)
		words[word] = struct{}{}
	}

	return words
}

func removeStopwords(s string) string {
	out := ""
	for _, word := range strings.Split(s, " ") {
		word = strings.TrimSpace(word)
		word = strings.ToLower(word)
		if _, ok := stopwords[word]; ok {
			continue
		}
		// more stopwords
		switch word {
		case "", "n/a", "vulnerability", "http", "https", "version":
			continue
		}
		if len(out) > 0 {
			out += " "
		}
		out += word
	}

	return out
}

//func train(csvData io.ReadSeeker) {
//	rawData, err := base.ParseCSVToInstancesFromReader(csvData, true)
//	if err != nil {
//		panic(err)
//	}
//}

//var alpha = regexp.MustCompile("[a-z ]+")

func isKnownVersionType(versionType string) bool {
	versionType = strings.ToLower(versionType)
	switch versionType {
	case "general", "release", "patch", "python", "rpm", "affected", "general availability", "semver", "maven", "original_commit_for_fix":
		return true
	default:
		return false
	}
	//return alpha.MatchString(versionType)
}

type rec struct {
	cve              string
	text             []string
	cpeVendorProduct string
}
