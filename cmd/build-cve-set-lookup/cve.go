package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path"

	"github.com/bmatcuk/doublestar/v4"
	"github.com/facebookincubator/nvdtools/wfn"

	"github.com/anchore/go-sync"
	"github.com/anchore/grype-db/pkg/provider/unmarshal/nvd/cvss31"
)

type cveVersion struct {
	Version     string `json:"version"`
	VersionType string `json:"versionType"`
	LessThan    string `json:"lessThan"`
}

type cveAffected struct {
	Vendor      string       `json:"vendor"`
	Product     string       `json:"product"`
	PackageName string       `json:"packageName"`
	Versions    []cveVersion `json:"versions"`
	Cpes        []string     `json:"cpes"`
}

type cveMetadata struct {
	ID    string `json:"cveId"`
	State string `json:"state"`
}

type cveReference struct {
	Url string `json:"url"`
}

type cveText struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type cveMetrics struct {
	cvss31.Cvss31 `json:"cvssV3_1"`
}

type cveCna struct {
	Affected     []cveAffected  `json:"affected"`
	References   []cveReference `json:"references"`
	Descriptions []cveText      `json:"descriptions"`
	Metrics      []cveMetrics   `json:"metrics"`
}

type cveContainers struct {
	Cna cveCna `json:"cna"`
}

type cveRecord struct {
	CveMetadata cveMetadata   `json:"cveMetadata"`
	Containers  cveContainers `json:"containers"`
}

func getSingleVendorProduct(affected []cveAffected) string {
	out := ""
	for _, a := range affected {
		cpeVendorProduct := getSingleCpeVendorProduct(a.Cpes)
		if out != "" && out != cpeVendorProduct {
			// there really shouldn't be multiple _different_ vendor products, we won't know the right one to use
			return ""
		}
		out = cpeVendorProduct
	}
	return out
}

func getSingleCpeVendorProduct(cpes []string) string {
	out := ""
	// if there are CPEs explicitly defined, use those
	for _, c := range cpes {
		cpe, _ := wfn.Parse(fmt.Sprintf("%v", c))
		if cpe == nil {
			continue
		}
		cpeVendorProduct := toVendorProduct(cpe)
		if out != "" && out != cpeVendorProduct {
			// there really shouldn't be multiple _different_ cpes, we won't know the right one to use
			return ""
		}
		out = cpeVendorProduct
	}
	return out
}

func readCVEFiles(executor sync.Executor, cveListDir string, glob string) []rec {
	paths := panget(doublestar.FilepathGlob(path.Join(cveListDir, glob)))

	// serial:
	// var knownRecords []rec
	//for _, p := range paths {
	//	knownRecords = append(knownRecords, readCveFile(p)...)
	//}

	// parallel:
	collector := sync.NewCollector[[]rec](executor)
	for _, p := range paths {
		p := p
		collector.Provide(func() []rec {
			return readCveFile(p)
		})
	}
	knownRecords := mergeAll(collector.Collect())

	return knownRecords
}

func readCveFile(cveFile string) []rec {
	if cveFile == "/Users/kzantow/Downloads/cvelistV5-main/cves-2024-03-05/2023/35xxx/CVE-2023-35926.json" {
		fmt.Print()
	}

	var cveRec cveRecord
	logif(json.Unmarshal(logget(os.ReadFile(cveFile)), &cveRec))

	if cveRec.CveMetadata.State == "REJECTED" {
		// skip rejected CVEs, as they may be wrong or just have no data
		return nil
	}

	if cveRec.CveMetadata.ID == "" {
		log("no cveId in:", cveFile)
		return nil
	}

	cveID := normalizeCve(cveRec.CveMetadata.ID)

	switch cveID {
	case "cve-2023-25571", "cve-2023-35926":
		fmt.Print()
	}

	var text []string

	for _, reference := range cveRec.Containers.Cna.References {
		url := reference.Url
		if url != "" {
			text = append(text, url)
		}
	}

	for _, description := range cveRec.Containers.Cna.Descriptions {
		if description.Lang == "en" {
			text = append(text, description.Value)
		}
	}

	if len(text) == 0 {
		log("no usable text in: ", cveFile)
		return nil
	}

	// if there's a single, known vendorProduct CPE, return only one entry with it
	singleVendorProduct := getSingleVendorProduct(cveRec.Containers.Cna.Affected)
	if singleVendorProduct != "" {
		// append any additional vendor/product text we can find since they all reference "the same" product; it'll be deduplicated later
		for _, a := range cveRec.Containers.Cna.Affected {
			text = append(text, a.Vendor, a.Product, a.PackageName)
		}
		return []rec{{
			cpe:  singleVendorProduct,
			cve:  cveID,
			text: text,
		}}
	}

	// we don't have a single known vendorProduct CPE, so include a record for the CPE text, which may be matched to a single CPE later
	for _, a := range cveRec.Containers.Cna.Affected {
		// if we found a CPE, skip this record; we have multiple CPEs and don't know the right one
		if len(a.Cpes) > 0 {
			continue
		}
		// also include any known affected product text we find
		text = append(text, a.Vendor, a.Product, a.PackageName)
	}

	// if we return
	return []rec{{
		cpe:  "", // this record does not have a known vendorProduct CPE
		cve:  cveID,
		text: text,
	}}
}
